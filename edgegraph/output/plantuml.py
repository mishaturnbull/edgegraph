#!/usr/env/python3
# -*- coding: utf-8 -*-

"""
Create PlantUML sourcecode for a graph.

This module *mostly* does not require PlantUML installed to operate.  It only
needs PlantUML installed to actually generate the images -- for only sourcecode
generation, it does not need to be installed.

.. seealso::

   PlantUML's homepage: https://plantuml.com/
"""

from __future__ import annotations

import functools
import os
import re
import subprocess
import shutil
import tempfile
import datetime

from edgegraph.structure import Universe, Vertex, DirectedEdge, UnDirectedEdge
from edgegraph.traversal import helpers
from edgegraph import version

PLANTUML_AUTOGEN_NOTE = f"""
note as n1
    PlantUML source generated by
    edgegraph on {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
end note
"""

#: rendering options, based on type
#:
#: keys:
#:
#:   * ``"type"``: the plantuml type used (default ``"object"``)
#:   * ``"stereotype"``: stereotype definition
#:   * ``"show_attrs"``: list of regex of attribute names to show.  passed to
#:     :py:func:`re.match`.
#:   * ``"user_render_func"``: function to call instead of performing builtin
#:     rendering
#:   * ``"title_format"``: format string for object title.
PLANTUML_RENDER_OPTIONS = {
        "skinparams": {
            "dpi": "300",
        },
        Vertex: {
            "type": "object",
            "stereotype_skinparams": {
                "BackgroundColor": "White",
                "FontColor": "Black",
                "StereotypeFontColor": "Black",
            },
            "show_attrs": [".+"],
            "title_format": "$id",
        },
        DirectedEdge: {
            "v1side": "",
            "v2side": ">",
        },
        UnDirectedEdge: {
            "v1side": "",
            "v2side": "",
        },
    }

def _resolve_options(clas, options):
    search = clas
    mro_idx = 0

    while search not in options:
        # we did not find the thing we were looking for
        mro_idx += 1
        search = clas.__mro__[mro_idx]

    # TODO: replace EAFP with LBYL in while loop?
    try:
        opts = options[search]
    except KeyError:
        return None

    # combine into a super-regex to use only one
    if "show_attrs" in opts and not isinstance(opts['show_attrs'], re.Pattern):
        superrgx = '(' + ')|('.join(opts['show_attrs']) + ')'
        opts['show_attrs'] = re.compile(superrgx)

    return opts

def _vertex_title(vertex, opts):
    attr_rgx = opts['show_attrs']
    attributes = [a for a in dir(vertex) if attr_rgx.match(a)]
    if opts['title_format'] == '$id':
        title = hex(id(vertex))
    else:
        title = opts['title_format'].format(**{a: vertex[a] for a in attributes})
    return title

def _one_vert_to_puml(vertex, options):
    opts = _resolve_options(type(vertex), options)

    if 'user_render_func' in opts:
        return opts['user_render_func'](vertex, options)
    
    # identify and match the attributes described in the show_attrs tag
    attr_rgx = opts['show_attrs']
    attributes = [a for a in dir(vertex) if attr_rgx.match(a)]

    title = _vertex_title(vertex, opts)
    hdrline = f"{opts['type']} {title} <<{type(vertex).__name__}>> {{\n"

    attrlines = []
    for attr in attributes:
        attrlines += f"    {{field}} {attr} = {vertex[attr]}\n"

    ftrline = "}\n"

    return hdrline + ''.join(attrlines) + ftrline

def _one_link_to_puml(lnk, options):
    opts = _resolve_options(type(lnk), options)
    v1, v2 = lnk.v1, lnk.v2
    v1ops = _resolve_options(type(v1), options)
    v2ops = _resolve_options(type(v2), options)
    v1puml = _vertex_title(v1, v1ops)
    v2puml = _vertex_title(v2, v2ops)
    v1e = opts["v1side"]
    v2e = opts["v2side"]

    out = f"{v1puml} {v1e}--{v2e} {v2puml}\n"
    return out

def _one_vert_to_skinparam(vert, options):
    opts = _resolve_options(type(vert), options)
    stereo = opts['stereotype_skinparams']
    typename = type(vert).__name__
    output = []
    for key, val in stereo.items():
        output.append(f"{key}<<{typename}>> {val}\n")
    return output

def render_to_plantuml_src(uni: Universe,
                           options: dict) -> str:
    """
    Render a universe to PlantUML source.

    .. todo::
    
       document this

    """

    if len(uni.vertices) == 0:
        return None

    components = ["@startuml\n"]
    links = set()
    skinparams = set()
    vertex_comps = []
    for vert in uni.vertices:
        vertex_comps.append(_one_vert_to_puml(vert, options))
        links |= set(vert.links)
        skinparams |= set(_one_vert_to_skinparam(vert, options))

    # these are the overall, diagram-wide skinparams
    if len(options['skinparams']):
        for spkey, spval in options['skinparams'].items():
            components.append(f"skinparam {spkey} {spval}\n")

    # these are the per-object skinparams
    if len(skinparams):
        components.append("skinparam object {\n")
        components.extend('    ' + s for s in skinparams)
        components.append("}\n")

    components.append(PLANTUML_AUTOGEN_NOTE)

    components.extend(vertex_comps)
    for link in links:
        components.append(_one_link_to_puml(link, options))

    

    components.append("@enduml\n")
    return ''.join(components)

def render_to_image(src: str,
                    out_file: str,
                    plantuml: str="plantuml"):
    """
    Accept string PlantUML source, and create an image.

    .. todo::

       document this
    """
    if not out_file.endswith('png'):
        raise ValueError("Only PNG's are supported at the moment!")

    tmpdir = tempfile.mkdtemp(prefix="edgegraph_puml_renderer_")
    
    # do all the stuff inside a try/finally, to make sure the tempdir always
    # gets cleaned up whether or not an exception happens
    try:
        srcfile = os.path.join(tmpdir, "in.puml")
        outfile = os.path.join(tmpdir, "in.png")
        with open(srcfile, 'w') as wfp:
            wfp.write(src)

        # https://plantuml.com/command-line
        subprocess.run([plantuml, srcfile], capture_output=True)
        shutil.move(outfile, out_file)
    except Exception:
        raise
    finally:
        shutil.rmtree(tmpdir)

